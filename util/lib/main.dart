// ignore_for_file: avoid_print

import 'dart:convert';
import 'dart:io';
import 'package:recase/recase.dart';

/// A map which adjusts icon ids starting with a number
///
/// Some icons cannot keep their id as identifier, as dart does not allow
/// numbers as the beginning of a variable names. The chosen solution is, to
/// write those parts out.
const Map<String, String> nameAdjustments = {
  "500px": "fiveHundredPx",
  "360-degrees": "threeHundredSixtyDegrees",
  "1": "one",
  "2": "two",
  "3": "three",
  "4": "four",
  "5": "five",
  "6": "six",
  "7": "seven",
  "8": "eight",
  "9": "nine",
  "0": "zero",
  "42-group": "fortyTwoGroup",
  "00": "zeroZero",
  "100": "hundred",
};

/// Some aliases clash with reserved words of dartlang. Those are ignored.
const List<String> ignoredAliases = ["try"];

/// Represents metadata for an icon.
///
/// [name] The name of the icon.
///
/// [label] The label of the icon.
///
/// [searchTerms] A list of search terms for the icon.
///
/// [styles] A list of styles for the icon.
///
/// [aliases] A list of aliases for the icon.
///
/// @[svg] A map containing the SVG data for the icon.
class IconMetadata {
  final String name;
  final String label;
  final List<String> searchTerms;
  final List<String> styles;
  final List<String> aliases;
  final Map<String, dynamic> svg;

  IconMetadata(
    this.name,
    this.label,
    this.searchTerms,
    this.styles,
    this.aliases,
    this.svg,
  );
}

// This function generates a Dart class that contains the definitions for all Font Awesome SVG icons
// based on the metadata provided in the `metadata` list. The generated code is then written to the
// file at the `outputPath`.
void main(List<String> rawArgs) async {
  // Print welcome message
  print('Font Awesome SVG Icons Configurator');

  // Check if icons.json file exists
  final File iconsJson = File('lib/icons/icons.json');
  final hasJsonFile = iconsJson.existsSync();
  if (!hasJsonFile) {
    // Print error message if the file does not exist
    print('Error: icons.json file not found!');
    exit(1); // Exit with error code 1
  }

  // Generate icon metadata and styles
  print('Generating files');
  final List<IconMetadata> metadata = [];
  final Set<String> styles = {};
  readAndPickMetadata(iconsJson, metadata, styles);

  // Generate icon definitions
  print('\nGenerating icon definitions');
  try {
    writeCodeToFile(
      () => generateIconDefinitionClass(metadata),
      'lib/font_awesome_svg_icons.dart',
    );
  } catch (e) {
    // Print error message if an exception occurs during file generation
    print('Error: Failed to generate icon definitions: $e');
    exit(1); // Exit with error code 1
  }

  // Print success message
  print('\nIcon definitions generated successfully!');
}

/// Writes the generated code to a file at the specified file path, then formats the file using the 'dart format' command.
///
/// [generator] A function that generates the code to be written to the file.
/// [filePath] The file path where the generated code should be written.
void writeCodeToFile(List<String> Function() generator, String filePath) {
  final List<String> generated = generator();
  final file = File(filePath);
  file.writeAsStringSync(generated.join('\n'));

  final result = Process.runSync('dart', ['format', filePath]);

  if (result.exitCode != 0) {
    print('Error occurred while formatting file: ${result.stderr}');
  } else {
    print('File formatted successfully.');
  }
}

/// Generates a Dart class containing static methods for each icon in the
/// given [metadata].
///
/// The generated class will have the following structure:
///
/// ```
/// class FontAwesomeSvgIcons {
///   // Static methods for each icon.
///   static FaSvgIcon iconName1({Color? color, double size = 20.0}) { ... }
///   static FaSvgIcon iconName2({Color? color, double size = 20.0}) { ... }
///   // ...
/// }
/// ```
///
List<String> generateIconDefinitionClass(List<IconMetadata> metadata) {
  final List<String> output = [
    'library font_awesome_svg_icons;',
    '',
    "import 'package:flutter/widgets.dart';",
    "import 'package:font_awesome_svg_icons/src/fa_svg_icon.dart';",
    "export 'package:font_awesome_svg_icons/src/fa_svg_icon.dart';",
  ];

  output.addAll([
    '',
    '// THIS FILE IS AUTOMATICALLY GENERATED!',
    '',
    'class FontAwesomeSvgIcons {',
  ]);

  if (metadata.isNotEmpty) {
    for (final IconMetadata icon in metadata) {
      for (final String style in icon.styles) {
        output.add(generateIconDocumentation(icon, style));
        output.add(generateIconDefinition(icon, style));
      }
    }
  }

  output.add('}');
  return output;
}

/// Generates the documentation for a given Font Awesome icon in a specific style.
///
/// The documentation includes the [style] and label of the [icon], as well as a link to the icon's page on the Font Awesome website.
///
/// If the icon has [searchTerms] associated with it, they will also be included in the documentation.
///
/// Returns a string containing the generated documentation.
String generateIconDocumentation(IconMetadata icon, String style) {
  var doc = '/// ${style.sentenceCase} ${icon.label} icon\n'
      '///\n'
      '/// https://fontawesome.com/icons/${icon.name}?style=$style';

  if (icon.searchTerms.isNotEmpty) {
    doc += '\n/// ${icon.searchTerms.join(", ")}';
  }

  return doc;
}

/// Generates a static method definition for a given [icon] and [style].
String generateIconDefinition(IconMetadata icon, String style) {
  // Normalize the icon name and get the raw SVG string for the specified style.
  final String iconName =
      normalizeIconName(icon.name, style, icon.styles.length);
  final String svgString = formatSvgString(icon.svg[style]['raw']);

  // Define the parameters for the generated method.
  const String colorParam = 'Color? color';
  const String sizeParam = 'double size = 20.0';
  final String semanticsParam = "String semanticsLabel = '$iconName',";
  final String params = [colorParam, sizeParam, semanticsParam].join(', ');

  // Generate the method definition with the given parameters.
  return '''
    static FaSvgIcon $iconName({$params}) {
      return FaSvgIcon(
        '$svgString',
        color: color,
        size: size,
        semanticsLabel: semanticsLabel,
      );
    }
  ''';
}

/// Normalizes the icon name by applying any necessary adjustments and adding a prefix
/// to avoid naming conflicts when an icon has multiple styles.
///
/// [iconName] The original name of the icon.
///
/// [style] The current style being processed.
///
/// [styleCompetitors] The total number of styles available for the icon.
String normalizeIconName(String iconName, String style, int styleCompetitors) {
  // Apply any necessary adjustments to the icon name
  String newIconName = nameAdjustments[iconName] ?? iconName;

  // Add a prefix to the icon name to avoid naming conflicts when the icon has
  // multiple styles, but only if the current style is not the regular style
  if (styleCompetitors > 1 && style != "regular") {
    newIconName = "${style}_$newIconName";
  }

  // Convert the normalized icon name to camel case and return it
  return newIconName.camelCase;
}

/// Reads the `icons.json` file and extracts the necessary metadata for the icons.
///
/// [iconsJson] File object representing the `icons.json` file.
///
/// [metadata] List of IconMetadata objects to store the extracted metadata.
///
/// [styles] Set of strings to store the styles of the icons.
void readAndPickMetadata(
    File iconsJson, List<IconMetadata> metadata, Set<String> styles) {
  dynamic rawMetadata;
  try {
    final content = iconsJson.readAsStringSync();
    rawMetadata = json.decode(content);
  } catch (_) {
    print(
        'Error: Invalid icons.json. Please make sure you copied the correct file.');
    exit(1);
  }

  Map<String, dynamic> icon;

  // Loop through each icon in the raw metadata and extract its metadata.
  for (final iconName in rawMetadata.keys) {
    icon = rawMetadata[iconName];

    final List<String> iconStyles = (icon['styles'] as List).cast<String>();

    // Skip the icon if it has no styles or if it's marked as private.
    if (iconStyles.isEmpty) continue;
    if (icon.containsKey('private') && icon['private']) continue;

    // Add the icon's styles to the set of styles.
    styles.addAll(iconStyles);

    // Extract the search terms and aliases for the icon.
    final List searchTermsRaw = icon['search']?['terms'] ?? [];
    final searchTerms = searchTermsRaw.map((e) => e.toString()).toList();

    final List aliasesRaw = icon['aliases']?['names'] ?? [];
    final aliases = aliasesRaw.map((e) => e.toString()).toList();

    // Extract the SVG data for the icon.
    final Map<String, dynamic> svg = icon['svg'] ?? [];

    // Create an IconMetadata object for the icon and add it to the metadata list.
    metadata.add(IconMetadata(
      iconName,
      icon['label'],
      searchTerms,
      iconStyles,
      aliases,
      svg,
    ));
  }
}

/// Formats an SVG string to add fill-opacity to all elements with the class "fa-secondary".
///
/// [svgString] The original SVG string to format.
///
/// [opacity] The opacity value to apply to the "fa-secondary" elements.
///
/// return A formatted SVG string with fill-opacity applied to "fa-secondary" elements.
String formatSvgString(
  String svgString, {
  double opacity = 0.4,
}) {
  try {
    final String formattedString = svgString.replaceAll(
        '<defs><style>.fa-secondary{opacity:.4}</style></defs>', '');
    final index = formattedString.indexOf('class="fa-secondary');

    return '${formattedString.substring(0, index)}fill-opacity="$opacity" ${formattedString.substring(index)}';
  } catch (_) {
    return svgString;
  }
}
